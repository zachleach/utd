# Networks: Exam 1

### 2024-01-31: [HW01 help], [ch 1.4.1] 
HW01 calculations and introduction to OSI model layers. Bits are transmitted between computers as electric signals on wires or wirelessly as EM waves through the air.

### 2024-01-31: [ch 1.4.2 - 1.4.6], [ch 2.2.3 or 1.5 (idk)]
Finish discussing OSI layers and then cover TCP/IP layers. TCP/IP is the protocol most used in practice and OSI is the underlying fundamental protocol theory.

### 2024-02-05: [ch 4.2 - 4.3], [ch 1.6.2], [ch 3.5]
Ethernet has transmission issues [4.2]. There is a dichotomy of networks, connectionless vs. connection-oriented, each has tradeoffs. Async data transfer solved a lot of problems in the data-link layer (needs elaboration), and is a key example of connection-oriented (in contrast to IP) [3.5].

### 2024-02-07 physical layer
hidden terminal problem


### 2024-02-12 physical layer
telephone networks
modem, tones of 1 and 0
digital, analog
point of presence (POP)
multiplexing 
FDM (frequency)
TDM (time), time slot, channel
WDM (wavelength)
quantization noise 


### 2024-02-14 TDM and FDM issues and resolutions, packet switching and circuit switching
The exam is on March 6th, calculator, open note, and every question is multiple choice. Content is, allegedly, heavily based on the lectures.

Frequency and time division multiplexing have an issue of signal overlap, resolved by guard bands and guard times (respectively). 

There are two types of switching, each has tradeoffs. Circuit switching is low latency, high predictability, but is complex to setup and doesn't scale well. Packet switching utilizes resources well, but requires packet header overhead, and has syncrhonization (packet loss) issues.

By definition, TDM sends packets in a set order. Receivers are physically setup to receive packets based on that order. TSI (time slot interchange) allows re-ordering of the packets sent over the physical medium before they are received, enabling higher flexibility for TDM.

Circuit switching has setup delay on the initial message. After the connection is setup, messages can be sent back and forth over the connection with no setup delay; each node reserved for the connection. This is in contrast to packet switching, where no nodes in the networks get reserved (better utilization of resources, but at the cost of transmission speed and overhead).

Packet switching has a notable advantage in terms of error resolution; namely, that errors received on the packet level, via packet switching, are much smaller than errors on the entire message, via cicuit switching, and therefore take much less time to resolve.

### 2024-02-19 
packet choice
500ms round trip voice transmission
? aquisition delay / packet sampling

Packet size choice tradeoffs
	Larger packets have smaller overhead to data ratio and are easier/faster to assemble and process. Smaller packets are more convenient to pad, have less real-time ATM aquisition delay, are less costly on packet loss / error, have less delay jitter (disorder of packet receival), and require smaller buffers for message receiving.

data link layer
sending the data between two adjacent nodes (e.g., routers)
? ordering
frames - the group of bits processed by the data link layer
purpose of frames is to localize errors and make them more identifiable  (purpose of frames)
frames consist of header, trailer, and payload (e.g., data link layer packet)

receives data from network layer, responsible for converting it to frame packets, and for handing off the payload to the network layer it's transmitting to

data link layer hands off the data to the physical layer as if it were transmitting directly to the other data link layer; the physical layer interprets it as an array of bits, and only cares about getting those bits to the other side of the network.

services, acknowledged, unacknowledged

unacknowledged-connectionless
	means that the destination doesn't message the sender that the data was received (connectionless); if frames are lost, no error correction is attempted. good for faster, lower quality transmission -- good for real-time transmission, because real-time traffic isn't re-transmitted regardless of error. also good on secure networks (LAN) where packet loss is infrequent.

acknowledged-connectionless
	if no acknowledgement is received in a given time interval, assume the packet is lost.
	piggy backing acknowledgment is when sender and receiver are sending messages back and forth, and the acknowledgment is contained in the messages sent.
	useful for unreliable networks (e.g., wireless networks) when error handling is important.

acknowledged-connection-oriented
	data link layer establishes connection before data transmission. 
	starts by sending the number of messages to be sent (frames are numbered and ordered). 
	guarantees reliable, recoverable, correctly ordered, delivery of frames; with exactly one frame sent.

	three scenarios
		if there is an error, don't send acknowledgement. if there is data loss, don't send acknowledgment. correct receival, but the acknowledgment is failed. 
		? how can the receiver know if the bits were incorrectly ordered
		? how do you handle when the acknowledgment fails so the frame is sent again 
	
	connection setup, transmission, connection release

routers consist of of two physical and data link layers, bridged by a network layer that handles the receival of incoming data and then the transmission of outgoing data (e.g., physical --> data link --> network --> data link --> physical). 

data link major issues
	how to identify frame bounadaries, recognize errors, and speed / conjestion control

framing
	identifying start and end of frame
	
	character count method (not good)
		let the first byte indicate the number of bytes in a frame (including the count byte); not good if there's an error in the count byte

	byte stuffing (most extensive frame delimiting scheme)
		frames start and end with flag byte (0111 1110)
		problematic if there is a flag contained within the frame's data (e.g., if the data could be confused as a flag); resolved by prepending an escape character to every flag within the data.
		algorithm is to prepend escape to every escape or flag bytes contained in the payload.
		the flag is identifiable by having no escape character preceding it
	
	bit stuffing
		byte stuffing is problematic when characters are represented with 16-bits instead of 8-bits
		handle the flag as a sequence of bits, rather than interpretting as bits
